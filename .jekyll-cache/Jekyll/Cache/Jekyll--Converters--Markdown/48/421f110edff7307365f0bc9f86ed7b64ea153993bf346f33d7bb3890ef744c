I"<h4 id="在javascript中没有类的概念函数就是第一类对象函数就是对象主要的表现形式有">在Javascript中没有类的概念，函数就是第一类对象。函数就是对象，主要的表现形式有：</h4>
<!-- more -->
<ul>
  <li>函数可以在运行时创建，也可以在运行的过程中创建。</li>
  <li>函数可以被分配给其他变量，可以将它们的引用复制给其他变量。</li>
  <li>函数可以作为参数传递给其他函数，且还可以作为其他函数的返回值返回。</li>
  <li>函数可以有自己的属性和方法。</li>
</ul>

<p><br />
本文将重点讨论函数作为返回值的形式:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span>  <span class="nx">setup</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">//函数setup的私有变量</span>
    <span class="kd">var</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">//返回函数访问私有变量</span>
    <span class="k">return</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="nx">count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">};</span>
<span class="p">};</span>
<span class="c1">//外部调用返回函数</span>
<span class="kd">var</span> <span class="nx">next</span> <span class="o">=</span> <span class="nx">setup</span><span class="p">();</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">next</span><span class="p">());</span> <span class="c1">//1</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">next</span><span class="p">());</span> <span class="c1">//2</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">next</span><span class="p">());</span> <span class="c1">//3</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">next</span><span class="p">());</span> <span class="c1">//4</span></code></pre></figure>

<h4 id="通过以上代码可以看到2个现象">通过以上代码，可以看到2个现象：</h4>
<ul>
  <li>变量count是函数setup的私有变量，外部函数是无法直接访问的，但是我们可以通过函数setup的内部匿名函数访问。如果我们将这个内部函数返回，外部调用该函数的时候就可以间接访问函数setup的私有变量。</li>
  <li>函数setup的私有变量count看起来像一个静态变量，每次调用都可以在上一次调用的基础上递增1。</li>
</ul>

<p><br />
现象1：在Javascript中，函数有两个特别的特征，一是前面说过的函数就是对象，二是函数提供局部作用域。这和Java中{}提供变量作用域是有区别的。
Javascript中的作用域链访问模式：</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">//全局作用域</span>
<span class="kd">var</span> <span class="nb">global</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">global</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">outer</span><span class="p">(){</span>
    <span class="c1">//函数outer的作用域</span>
    <span class="kd">var</span> <span class="nx">outer_v</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">outer</span><span class="dl">"</span><span class="p">;</span>
    <span class="nx">alert</span><span class="p">(</span><span class="nb">global</span><span class="p">);</span> <span class="c1">//global，能访问全局作用域的变量</span>
    <span class="nx">alert</span><span class="p">(</span><span class="nx">inner</span><span class="p">);</span> <span class="c1">//undefined，不能访问内部函数作用域的变量</span>
    
    <span class="kd">var</span> <span class="nx">inner</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
        <span class="c1">//函数inner的作用域</span>
        <span class="kd">var</span> <span class="nx">inner_v</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">inner</span><span class="dl">"</span><span class="p">;</span>
        <span class="nx">alert</span><span class="p">(</span><span class="nx">outer_v</span><span class="p">);</span> <span class="c1">//outer，能访问外部函数作用域的变量</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nx">alert</span><span class="p">(</span><span class="nx">outer_v</span><span class="p">);</span> <span class="c1">//undefined, 不能访问oute函数作用域的变量。</span></code></pre></figure>

<p>以上代码就是为了说明Javascript语言特有的“链式作用域”结构（chain scope）。即子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。</p>

<p><br />
现象2：为什么函数setup的私有变量count的表现好似Java中的静态变量？</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript">    <span class="kd">var</span> <span class="nx">next</span> <span class="o">=</span> <span class="nx">setup</span><span class="p">();</span></code></pre></figure>

<p>不难理解，这句话调用之后，我们创建了一个全局变量next指向了函数setup的内部函数，所以setup的内部函数将一直存在于内存中，不会被垃圾回收器回收。而内部函数的存在是依赖外部函数setup的，所以setup也会一直存在于内存中而不被销毁。所以其私有属性的值不会被重置。特别注意，Javascript中函数不是类，是第一类对象，归根结底是对象，相当于内存中存在一个不被销毁的对象，所以该对象的属性不会被改变，这和Java中的静态变量是有区别的。
可以看出，随意使用返回函数是很消耗性能的，因为这些函数对象将一直存在于内存中。
<br /></p>

<p>其实以上阐述的这种返回函数的模式，就是Javascript中所谓的闭包。  <br />
闭包的概念：  <br />
官方”的解释是：闭包是一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。  <br />
我的理解是，闭包就是在函数外部使用函数内部的返回函数。  <br />
也就是说：当函数a的内部函数b被函数a外的一个变量引用的时候，就创建了一个闭包。</p>

<p>闭包的作用主要就是为了保护私有变量。</p>

<h4 id="使用闭包的注意事项">使用闭包的注意事项：</h4>
<ul>
  <li>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。</li>
  <li>由于Javascript特殊的作用域链，闭包会在父函数外部，改变父函数内部变量的值。</li>
</ul>

:ET